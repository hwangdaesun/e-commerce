# MySQL 비관적 락(Pessimistic Lock)을 활용한 쿠폰 선착순 발급 및 중복 방지 동시성 제어

## 1. 개요 및 목표

이커머스 서비스의 핵심 기능인 '선착순 쿠폰 발급' 시스템을 구축함에 있어, 분산 락(Redis) 없이 **오직 MySQL의 기능(Lock & Transaction)**만을 활용하여 데이터 정합성을 보장하는 것을 목표로 했습니다.

- **핵심 목표:**
    1. **재고 초과 방지:** 정해진 수량(10개) 이상의 쿠폰이 발급되어서는 안 된다.
    2. **1인 1매 제한:** 동일한 사용자가 동시에 여러 요청을 보내더라도 단 1개의 쿠폰만 발급되어야 한다.

---

## 2. 테스트 시나리오 및 검증 조건

`JUnit5`와 `ExecutorService`를 활용하여 멀티스레드 환경에서의 동시성 테스트를 수행했습니다.

### **시나리오 A: 재고 정합성 테스트 (100명 동시 요청)**

- **Given:** 쿠폰 재고 10개, 사용자 100명이 동시에 발급 요청.
- **When:** 100개의 스레드가 동시에 `issue()` 메서드 호출.
- **Then (검증):**
    - 성공 횟수는 정확히 **10회**여야 한다.
    - 실패 횟수는 정확히 **90회**여야 한다.
    - 남은 재고(`remainingQuantity`)는 **0**이어야 한다.

### **시나리오 B: 중복 발급 방지 테스트 (동일인 10회 동시 요청)**

- **Given:** 쿠폰 재고 100개, **User ID 1번**이 동시에 10회 발급 요청.
- **When:** 10개의 스레드가 동시에 같은 `userId`로 `issue()` 메서드 호출.
- **Then (검증):**
    - 성공 횟수는 정확히 **1회**여야 한다.
    - 실패 횟수는 **9회**여야 한다.
    - `UserCoupon` 테이블에 해당 유저의 쿠폰은 **1개**만 존재해야 한다.

---

## 3. 문제 해결 과정 (Troubleshooting)

### **3.1 발생했던 문제: 1인 1매 중복 발급 제한 실패**

초기 구현에서는 비관적 락(`SELECT ... FOR UPDATE`)을 사용했음에도 불구하고, **시나리오 B(동일인 중복 요청)** 테스트에서 간헐적으로 2개 이상의 쿠폰이 발급되는 현상이 발생했습니다.

### **3.2 원인 분석: MySQL 격리 수준과 스냅샷 생성 시점**

MySQL의 기본 격리 수준인 **REPEATABLE READ**와 **MVCC(Multi-Version Concurrency Control)** 메커니즘이 원인이었습니다.

1. **기존 로직 순서:** 일반 조회(유효성 검사) → **배타락 획득(Stock)** → 재고 차감 → 발급
2. **문제 상황:**
    - 트랜잭션 A와 B가 동시에 시작됩니다.
    - **A와 B가 동시에 일반 조회(유효성 검사)를 수행합니다.** 이 시점에 MySQL은 각 트랜잭션에 대해 **스냅샷(Snapshot)**을 생성합니다. (이 시점엔 둘 다 쿠폰이 없음)
    - A가 먼저 락을 획득하고 쿠폰을 발급한 뒤 커밋합니다.
    - B가 뒤늦게 락을 획득합니다.
    - **결정적 원인:** B가 다시 유저의 쿠폰 보유 여부를 검사할 때, **이미 생성된 과거의 스냅샷(쿠폰 없음)**을 기준으로 데이터를 읽어옵니다. (`REPEATABLE READ`의 특성)
    - 결과적으로 B도 검증을 통과하고 중복 발급을 수행합니다.

### **3.3 해결책: 락 획득 시점 변경 (진입 시 즉시 Locking)**

스냅샷이 생성되기 전에 **물리적인 락을 먼저 획득**하여 트랜잭션의 순서를 강제하고, 후행 트랜잭션이 선행 트랜잭션의 커밋 결과를 볼 수 있도록 변경했습니다.

- **수정된 로직:** **배타락 획득(Stock) 및 진입** → 유효성 검사(만료/중복) → 재고 차감 → 발급
- 트랜잭션 시작 직후 `findByCouponIdWithPessimisticLock`을 호출하여 다른 스레드의 접근을 차단(Blocking)합니다.
- 후행 트랜잭션은 락을 획득한 시점에 **새로운 조회(Current Read)**를 수행하거나, 선행 트랜잭션이 커밋된 이후의 데이터를 기반으로 검증을 수행하게 되어 중복 발급을 막을 수 있습니다.

# 
