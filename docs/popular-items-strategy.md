# 인기 상품 조회 전략

## 핵심 전략

인기 상품 조회시 Look Aside 전략 사용.

### 1. 캐시 스탬피드 방지 - RENAME 전략
**문제**: TTL 만료 시점에 동시 요청이 DB로 몰려 부하 발생

**해결**: 매 정각 스케줄러가 능동적으로 캐시 갱신
- 임시 키에 최신 데이터 저장 (TTL 25시간)
- Redis RENAME 명령으로 원자적 교체
- 데이터 공백 0초 보장 (기존 캐시 유지하며 교체)

**효과**:
- 동시 요청이 DB로 몰리는 현상 방지
- 항상 유효한 캐시 유지

### 2. 재고 기반 조건부 캐싱
**전략**: 재고 임계값(10개)을 기준으로 캐싱 여부 결정

- **재고 > 10**: 캐싱 O (성능 우선, TTL 1시간)
- **재고 ≤ 10**: 캐싱 X (정확도 우선, 매번 DB 조회)

**이유**:
- 품절 임박 상품은 실시간 정보가 중요
- 재고 충분한 상품은 성능 우선

### 3. 자동 캐시 무효화
**시점**: 재고 차감 후 재고가 임계값(10) 이하로 떨어질 때

**동작**:
- 재고 감소 트랜잭션에서 자동 캐시 삭제
- 품절 임박 상품은 이후 조회 시 캐싱 안 됨

**효과**:
- 낮은 재고 상품은 항상 최신 정보 제공

---

## 성능 개선 효과

| 조회 유형 | 캐싱 전      | 캐싱 후    | 개선율        |
|---------|-----------|---------|------------|
| 인기 상품 전체 목록 | 7~8s      | 30~50ms | **15~25배** |
| 인기 상품 상세 조회 | 300~400ms | 30~50ms | **6~15배**  |

---

## 캐시 설정

### Redis 캐시 이름
- **popular-items**: 인기 상품 전체 목록 (TTL 1일)
- **item**: 개별 상품 상세 (TTL 1시간)

### 캐시 관련 상수
- **TEMP_SUFFIX**: `:temp` (임시 키 접미사)
- **LOW_STOCK_THRESHOLD**: `10` (재고 임계값)

---

## 장점

1. **캐시 스탬피드 완벽 방지**: RENAME 전략으로 동시 요청 DB 부하 제거
2. **실시간 정확도 보장**: 재고 부족 상품은 항상 최신 정보
3. **성능 대폭 개선**: 5~20배 응답 속도 향상
4. **간단한 구현**: Spring Cache + 스케줄러로 쉽게 관리
5. **자동 관리**: 캐시 갱신과 무효화가 자동으로 동작

## 단점

1. **메모리 중복 사용**: limit별로 별도 캐시 생성 (약 70KB, 무시 가능)
2. **재고 정보 지연**: 충분한 재고 상품은 최대 1시간 지연 가능 (주문 시 검증하므로 문제 없음)
3. **스케줄러 의존**: 정각마다 DB 조회 발생

---

## 적합성

### ✅ 적합한 경우
- 조회 빈도가 변경 빈도보다 압도적으로 높음
- 재고가 충분한 상품이 대부분
- 1시간 정도 데이터 지연 허용 가능
- 읽기 성능이 중요

### ❌ 부적합한 경우
- 실시간 재고 정확도가 필수적
- 모든 상품 재고가 항상 낮음
- 동적 가격 변경이 빈번

---

## 대안: 실시간성이 필요한 경우

### Redis Sorted Set 방식 (현재 구현)

**전략**: Item ID만 Sorted Set에 저장하고, 조회/주문 시 실시간으로 score를 업데이트

#### Redis Sorted Set 구조

##### 일간 인기 상품
- **Key**: `popular:items:daily`
- **Member**: `itemId` (상품 ID, String)
- **Score**: 인기도 점수 (조회수 × 2 + 판매량 × 8)
- **갱신 주기**: 매 시간 정각 (최근 1일 데이터 기준)

##### 주간 인기 상품
- **Key**: `popular:items:weekly`
- **Member**: `itemId` (상품 ID, String)
- **Score**: 인기도 점수 (조회수 × 2 + 판매량 × 8)
- **갱신 주기**: 매 시간 정각 (최근 7일 데이터 기준)

#### 실시간 Score 업데이트

**상품 조회 시** (ItemPopularityService.incrementViewScore):
```java
// 일간/주간 ZSET에서 해당 상품의 score를 +2 증가
ZINCRBY popular:items:daily {itemId} 2
ZINCRBY popular:items:weekly {itemId} 2
```

**주문 생성 시** (ItemPopularityService.incrementSalesScore):
```java
// 일간/주간 ZSET에서 해당 상품의 score를 +8 증가
ZINCRBY popular:items:daily {itemId} 8
ZINCRBY popular:items:weekly {itemId} 8
```

**특징**:
- ZSET에 itemId가 존재하는 경우에만 score 증가 (상위 100개 상품만 실시간 업데이트)
- 조회/구매 즉시 인기도 점수 반영
- 별도 트랜잭션 없이 빠른 업데이트

#### 스케줄러 기반 랭킹 갱신

**실행 주기**: 매 시간 정각 (cron: `0 0 * * * *`)

**동작 방식** (ItemPopularityScheduler):
1. DB에서 최근 1일/7일 조회수 및 판매량 집계
2. 인기도 점수 계산: `(조회수 × 2) + (판매량 × 8)`
3. 상위 100개 상품 선정
4. 기존 ZSET 삭제 후 새로운 데이터로 교체

**효과**:
- 신규 인기 상품이 랭킹에 진입
- 인기도가 떨어진 상품은 랭킹에서 제외
- 장기간 집계 오차 보정 (실시간 증가만으로는 감소 반영 불가)

#### 인기 상품 조회

**API**: `GET /api/v1/items/popular?period={DAILY|WEEKLY}`

**동작 방식**:
1. Redis ZSET에서 score 역순으로 상위 100개 조회
   ```java
   ZREVRANGE popular:items:daily 0 99
   ```
2. 조회된 itemId 목록으로 DB에서 상품 상세 정보 조회
3. 순서 유지하며 응답 반환

**응답 시간**: 평균 30~50ms

#### 주요 상수

**가중치** (PopularityConstants):
- `VIEW_SCORE_WEIGHT`: 2 (조회 시 score 증가량)
- `SALES_SCORE_WEIGHT`: 8 (판매 시 score 증가량)

**랭킹 설정**:
- `POPULAR_ITEMS_LIMIT`: 100 (ZSET에 저장할 상품 개수)

**Redis 키**:
- `POPULAR_ITEMS_DAILY_KEY`: `popular:items:daily`
- `POPULAR_ITEMS_WEEKLY_KEY`: `popular:items:weekly`

#### 장점

1. **준실시간 인기도 반영**
   - 상품 조회/구매 시 즉시 Redis ZSET score 업데이트
   - 사용자 행동이 곧바로 인기도에 반영

2. **메모리 효율적**
   - 상위 100개 상품 ID만 저장 (약 1~2KB)
   - 상품 상세 정보는 별도 DB 조회로 중복 방지

3. **빠른 조회 성능**
   - Redis ZREVRANGE 명령으로 O(log(N) + M) 시간 복잡도
   - 평균 응답 시간 30~50ms

4. **유연한 기간 선택**
   - 일간/주간 랭킹 독립적으로 관리
   - 단일 ZSET에서 다양한 limit 값 조회 가능

5. **자동 랭킹 관리**
   - 스케줄러가 매 시간 자동으로 랭킹 갱신
   - 인기 하락 상품 자동 제외

#### 단점

1. **상품 상세 정보 추가 조회**
   - ZSET에는 ID만 저장되어 있어 DB 조회 필요
   - N+1 문제 방지를 위해 `findAllByItemIdIn` 사용

2. **상위 100개만 실시간 반영**
   - ZSET에 없는 상품은 조회/구매해도 score 증가 안 됨
   - 랭킹 진입은 매 시간 스케줄러에 의존

3. **스케줄러 부하**
   - 매 시간마다 DB 집계 쿼리 실행
   - 데이터양 증가 시 집계 시간 증가 가능

#### 사용 시기

- **실시간 인기 순위가 중요한 경우**
- **인기도가 빠르게 변동하는 이벤트 기간**
- **사용자 행동을 즉시 반영해야 하는 경우**
- **다양한 기간별 랭킹이 필요한 경우**